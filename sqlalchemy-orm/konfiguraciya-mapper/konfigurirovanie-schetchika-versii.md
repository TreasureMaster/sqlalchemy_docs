# Конфигурирование счетчика версий

[Mapper](https://docs.sqlalchemy.org/en/14/orm/mapping\_api.html#sqlalchemy.orm.Mapper) поддерживает управление столбцом [version id](https://docs.sqlalchemy.org/en/14/glossary.html#term-version-id-column), который представляет собой один столбец таблицы, который увеличивает или иным образом обновляет свое значение каждый раз, когда происходит **UPDATE** для отображаемой таблицы. Это значение проверяется каждый раз, когда ORM выдает **UPDATE** или **DELETE** для строки, чтобы гарантировать, что значение, хранящееся в памяти, соответствует значению базы данных.

{% hint style="danger" %}
Поскольку функция управления версиями основана на сравнении записи объекта в памяти, эта функция применяется только к процессу [Session.flush()](https://docs.sqlalchemy.org/en/14/orm/session\_api.html#sqlalchemy.orm.Session.flush), где ORM сбрасывает отдельные строки в памяти в базу данных. Это не вступает в силу при выполнении многострочного **UPDATE** или **DELETE** с использованием методов [Query.update()](https://docs.sqlalchemy.org/en/14/orm/query.html#sqlalchemy.orm.Query.update) или [Query.delete()](https://docs.sqlalchemy.org/en/14/orm/query.html#sqlalchemy.orm.Query.delete), поскольку эти методы только выдают оператор **UPDATE** или **DELETE**, но в противном случае не имеют прямого доступа к содержимому этих строк, которые затронуты.
{% endhint %}

Цель этой функции — определить, когда две параллельные транзакции изменяют одну и ту же строку примерно в одно и то же время, или, в качестве альтернативы, обеспечить защиту от использования «устаревшей» строки в системе, которая может повторно использовать данные из предыдущей транзакция без обновления (например, если для сеанса [Session](https://docs.sqlalchemy.org/en/14/orm/session\_api.html#sqlalchemy.orm.Session) установлено `expire_on_commit=False`, можно повторно использовать данные из предыдущей транзакции).

{% hint style="info" %}
**Параллельные обновления транзакций**

При обнаружении одновременных обновлений в транзакциях обычно бывает так, что уровень изоляции транзакций базы данных ниже уровня [повторяемого чтения](https://docs.sqlalchemy.org/en/14/glossary.html#term-repeatable-read); в противном случае транзакция не будет подвергаться воздействию нового значения строки, созданного параллельным обновлением, которое конфликтует с локально обновленным значением. В этом случае функция управления версиями SQLAlchemy обычно бесполезна для обнаружения конфликтов внутри транзакции, хотя ее все же можно использовать для обнаружения устаревания между транзакциями.

База данных, обеспечивающая повторяющиеся операции чтения, обычно либо блокирует целевую строку от одновременного обновления, либо использует некоторую форму управления параллельным выполнением нескольких версий, так что она выдает ошибку при фиксации транзакции. **version\_id\_col** SQLAlchemy — это альтернатива, которая позволяет отслеживать версии для определенных таблиц внутри транзакции, для которых в противном случае этот уровень изоляции мог бы не быть установлен.
{% endhint %}

{% hint style="info" %}
Смотри также:

[Уровень изоляции повторяющегося чтения](https://www.postgresql.org/docs/9.1/static/transaction-iso.html#XACT-REPEATABLE-READ) — реализация PostgreSQL повторяемого чтения, включая описание состояния ошибки.
{% endhint %}

## Простой счетчик версий

Самый простой способ отслеживать версии — добавить целочисленный столбец в отображаемую таблицу, а затем установить его как **version\_id\_col** в параметрах преобразователя:

```python
class User(Base):
    __tablename__ = 'user'

    id = Column(Integer, primary_key=True)
    version_id = Column(Integer, nullable=False)
    name = Column(String(50), nullable=False)

    __mapper_args__ = {
        "version_id_col": version_id
    }
```

{% hint style="info" %}
**Настоятельно рекомендуется**, чтобы столбец **version\_id** был сделан **NOT NULL**. Функция управления версиями **не поддерживает** значение **NULL** в столбце управления версиями.
{% endhint %}

Выше сопоставление пользователя **User** отслеживает целочисленные версии с помощью столбца **version\_id**. При первом сбросе объекта типа **User** столбцу **version\_id** будет присвоено значение `«1»`. Затем **UPDATE** таблицы позже всегда будет выдаваться способом, подобным следующему:

```sql
UPDATE user SET version_id=:version_id, name=:name
WHERE user.id = :user_id AND user.version_id = :user_version_id
{"name": "new name", "version_id": 2, "user_id": 1, "user_version_id": 1}
```

Приведенный выше оператор **UPDATE** обновляет строку, которая не только соответствует `user.id = 1`, но также требует, чтобы `user.version_id = 1`, где `«1»` — это последний идентификатор версии, который мы использовали для этого объекта. Если транзакция в другом месте независимо изменила строку, этот идентификатор версии больше не будет совпадать, и оператор **UPDATE** сообщит, что строки не совпадают; это условие, которое SQLAlchemy проверяет, чтобы ровно одна строка соответствовала нашему оператору **UPDATE** (или **DELETE**). Если совпадают нулевые строки, это указывает на то, что наша версия данных устарела, и возникает ошибка [StaleDataError](https://docs.sqlalchemy.org/en/14/orm/exceptions.html#sqlalchemy.orm.exc.StaleDataError).

## Пользовательские счетчики/типы версий

Другие виды значений или счетчиков могут использоваться для управления версиями. Общие типы включают даты и идентификаторы GUID. При использовании схемы альтернативного типа или счетчика SQLAlchemy предоставляет ловушку для этой схемы с помощью аргумента **version\_id\_generator**, который принимает вызываемый объект генерации версии. Этому вызываемому объекту передается значение текущей известной версии, и ожидается, что он вернет последующую версию.

Например, если бы мы хотели отслеживать версии нашего класса **User** с помощью случайно сгенерированного GUID, мы могли бы сделать это (обратите внимание, что некоторые серверные части поддерживают собственный тип GUID, но здесь мы проиллюстрируем это простой строкой):

```python
import uuid

class User(Base):
    __tablename__ = 'user'

    id = Column(Integer, primary_key=True)
    version_uuid = Column(String(32), nullable=False)
    name = Column(String(50), nullable=False)

    __mapper_args__ = {
        'version_id_col':version_uuid,
        'version_id_generator':lambda version: uuid.uuid4().hex
    }
```

Механизм постоянства будет вызывать `uuid.uuid4()` каждый раз, когда объект **User** подвергается **INSERT** или **UPDATE**. В этом случае наша функция генерации версии может игнорировать входящее значение версии, так как функция `uuid4()` генерирует идентификаторы без каких-либо предварительных значений. Если бы мы использовали последовательную схему управления версиями, такую как числовая или система специальных символов, мы могли бы использовать данную версию, чтобы помочь определить последующее значение.

{% hint style="info" %}
Смотри также:

[Backend-agnostic GUID Type](https://docs.sqlalchemy.org/en/14/core/custom\_types.html#custom-guid-type)
{% endhint %}

## Счетчики версий на стороне сервера

Генератор **version\_id\_generator** также можно настроить так, чтобы он полагался на значение, сгенерированное базой данных. В этом случае базе данных потребуются некоторые средства для генерации новых идентификаторов, когда строка подвергается **INSERT**, а также **UPDATE**. Для случая **UPDATE** обычно требуется триггер обновления, если рассматриваемая база данных не поддерживает какой-либо другой собственный идентификатор версии. В частности, база данных **PostgreSQL** поддерживает системный столбец с именем **xmin**, который обеспечивает управление версиями **UPDATE**. Мы можем использовать столбец PostgreSQL **xmin** для версии нашего класса **User** следующим образом:

```python
from sqlalchemy import FetchedValue

class User(Base):
    __tablename__ = 'user'

    id = Column(Integer, primary_key=True)
    name = Column(String(50), nullable=False)
    xmin = Column("xmin", String, system=True, server_default=FetchedValue())

    __mapper_args__ = {
        'version_id_col': xmin,
        'version_id_generator': False
    }
```

С приведенным выше сопоставлением ORM будет полагаться на столбец **xmin** для автоматического предоставления нового значения счетчика идентификатора версии.

{% hint style="info" %}
**создание таблиц, ссылающихся на системные столбцы**

В приведенном выше сценарии, поскольку **xmin** — это системный столбец, предоставляемый PostgreSQL, мы используем аргумент `system=True`, чтобы пометить его как системный столбец, опущенный в операторе **CREATE TABLE**. Тип данных этого столбца — внутренний тип PostgreSQL, называемый **xid**, который действует в основном как строка, поэтому мы используем тип данных **String**.
{% endhint %}

ORM обычно не извлекает активно значения, сгенерированные базой данных, когда выдает **INSERT** или **UPDATE**, вместо этого оставляя эти столбцы как **«expired»** и подлежащие извлечению при следующем доступе к ним, если только не установлен флаг `await_defaults mapper()`. Однако, когда используется столбец версии на стороне сервера, ORM необходимо активно извлекать вновь сгенерированное значение. Это делается для того, чтобы счетчик версий устанавливался до того, как какая-либо параллельная транзакция сможет снова его обновить. Эту выборку также лучше всего выполнять одновременно с инструкцией **INSERT** или **UPDATE** с использованием [RETURNING](https://docs.sqlalchemy.org/en/14/glossary.html#term-RETURNING), в противном случае, если после этого выдается инструкция **SELECT**, все еще существует потенциальное состояние гонки, когда счетчик версий может измениться до того, как его можно будет получить.

Когда целевая база данных поддерживает **RETURNING**, инструкция **INSERT** для нашего класса **User** будет выглядеть так:

```sql
INSERT INTO "user" (name) VALUES (%(name)s) RETURNING "user".id, "user".xmin
{'name': 'ed'}
```

Там, где указано выше, ORM может получить любые вновь сгенерированные значения первичного ключа вместе с сгенерированными сервером идентификаторами версий в одном операторе. Когда серверная часть не поддерживает **RETURNING**, для _**каждого**_ **INSERT** и **UPDATE** должен быть выдан дополнительный **SELECT**, что гораздо менее эффективно, а также вводит возможность пропущенных счетчиков версий:

```sql
INSERT INTO "user" (name) VALUES (%(name)s)
{'name': 'ed'}

SELECT "user".version_id AS user_version_id FROM "user" where
"user".id = :param_1
{"param_1": 1}
```

_**Настоятельно рекомендуется**_ использовать счетчики версий на стороне сервера только в случае крайней необходимости и только на бэкендах, поддерживающих [RETURNING](https://docs.sqlalchemy.org/en/14/glossary.html#term-RETURNING), например, **PostgreSQL**, **Oracle**, **SQL Server** (хотя в SQL Server есть [серьезные оговорки](https://blogs.msdn.com/b/sqlprogrammability/archive/2008/07/11/update-with-output-clause-triggers-and-sqlmoreresults.aspx) при использовании триггеров), **Firebird**.

## Программные или условные счетчики версий

Когда для **version\_id\_generator** установлено значение `False`, мы также можем программно (и условно) установить идентификатор версии для нашего объекта так же, как мы назначаем любой другой сопоставленный атрибут. Например, если бы мы использовали наш пример UUID, но установили для **version\_id\_generator** значение **False**, мы можем установить идентификатор версии по нашему выбору:

```python
import uuid

class User(Base):
    __tablename__ = 'user'

    id = Column(Integer, primary_key=True)
    version_uuid = Column(String(32), nullable=False)
    name = Column(String(50), nullable=False)

    __mapper_args__ = {
        'version_id_col':version_uuid,
        'version_id_generator': False
    }

u1 = User(name='u1', version_uuid=uuid.uuid4())

session.add(u1)

session.commit()

u1.name = 'u2'
u1.version_uuid = uuid.uuid4()

session.commit()
```

Мы также можем обновить наш объект **User** без увеличения счетчика версий; значение счетчика останется неизменным, и инструкция **UPDATE** по-прежнему будет сверяться с предыдущим значением. Это может быть полезно для схем, в которых только определенные классы **UPDATE** чувствительны к проблемам параллелизма:

```
# оставит version_uuid без изменений
u1.name = 'u3'
session.commit()
```

{% hint style="info" %}
**Новое в версии 0.9.0**: поддержка программного и условного отслеживания идентификаторов версий.
{% endhint %}
